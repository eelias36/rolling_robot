#!/usr/bin/env python
import rospy
from std_msgs.msg import String, ByteMultiArray, Float32
from sensor_msgs.msg import Imu

import numpy as np
from pyquaternion import Quaternion
from hardware_interface.imu import *
from hardware_interface.SX1509 import *
import hardware_interface.IO_Types as IO_Types

import time
import math

import busio
import board
from adafruit_bus_device.i2c_device import I2CDevice


class Hardware_interface:
    def __init__(self):
        rospy.init_node('hardware_interface_node', anonymous=True, disable_signals=True)

        rospy.Subscriber("/relay_states", ByteMultiArray, self.relay_states_callback, queue_size=1)
        rospy.Subscriber("/driver_speed", Float32, self.driver_speed_callback, queue_size=1)

        self.imu_pub = rospy.Publisher("/imu/data_raw", Imu, queue_size=1)
        self.extended_switches_pub = rospy.Publisher("/extended_switches", ByteMultiArray, queue_size=1)
        self.retracted_switches_pub = rospy.Publisher("/retracted_switches", ByteMultiArray, queue_size=1)
        
        # ---initialize IMU---
        self.imu = MinIMU_v5_pi()
        self.imu_q = Quaternion(-0.2705981, -0.2705981, -0.6532815, -0.6532815) # for transform from imu frame to body frame

        # ---initialize expander 1---
        DEVICE_ADDRESS1 = 0x3E  # device address of SX1509

        #Set up I2C
        comm_port = busio.I2C(board.SCL, board.SDA)
        device1 = I2CDevice(comm_port, DEVICE_ADDRESS1)

        # ---initialize expander 1 (extended switches)---
        self.IOExpander1 = SX1509(comm_port)

        #Set up pins
        for pin in range(16):
            self.IOExpander1.pinMode(pin, IO_Types.PIN_TYPE_INPUT_PULLUP)

        # ---initialize expander 2 (retracted switches)---
        DEVICE_ADDRESS2 = 0x3F  # device address of SX1509

        #Set up I2C
        device2 = I2CDevice(comm_port, DEVICE_ADDRESS1)

        #Initialize the expander
        self.IOExpander2 = SX1509(comm_port)

        #Set up pins
        for pin in range(16):
            self.IOExpander2.pinMode(pin, IO_Types.PIN_TYPE_INPUT_PULLUP)

        # # ---initialize expander 3 (relay outputs)---
        # DEVICE_ADDRESS3 = 0x70  # device address of SX1509

        # #Set up I2C
        # device3 = I2CDevice(comm_port, DEVICE_ADDRESS1)

        # #Initialize the expander
        # self.IOExpander3 = SX1509.SX1509(comm_port)

        # #Set up pins
        # for pin in range(16):
        #     self.IOExpander3.pinMode(pin, IO_Types.PIN_TYPE_OUTPUT)

        return


    def relay_states_callback(self, data):
        for i in range(16):
            relay_states_temp[i] = data.data[i]

        self.relay_states = relay_states_temp.copy()
        update_relay_outputs()
        return

    def update_relay_outputs(self):
        for i in range(16):
            self.IOExpander3.digitalWrite(i, 1-self.relay_states[i])  # To turn relay on, pull pin to low
        return


    def driver_speed_callback(self, data):
        self.driver_speed = data.data
        return
        
    def start_running(self):
        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():
            self.imu_pub.publish( self.get_imu_msg() )
            self.extended_switches_pub.publish( self.get_extended_switches_msg() )
            self.retracted_switches_pub.publish( self.get_retracted_switches_msg() )
            rate.sleep()

    def get_extended_switches_msg(self):
        extended_switches_msg = ByteMultiArray()

        for i in range(16):
            extended_switches_msg.data.append( self.IOExpander1.digitalRead(i) )

        return extended_switches_msg

    def get_retracted_switches_msg(self):
        retracted_switches_msg = ByteMultiArray()

        for i in range(16):
            retracted_switches_msg.data.append( self.IOExpander2.digitalRead(i) )

        return retracted_switches_msg

    def get_imu_msg(self):
        imu_msg = Imu()

        accel = np.array( self.imu.readAccelerometer() )
        accel = self.imu_q.rotate(accel)
        # print(accel)
        # print("Gyro: ")
        gyro = np.array( self.imu.readGyro() )
        gyro = self.imu_q.rotate(gyro)
        # print(gyro)

        imu_msg.header.stamp = rospy.Time.now()
        imu_msg.header.frame_id = 'base_link'

        # convert from deg/s to rad/s
        imu_msg.angular_velocity.x = math.radians(gyro[0])
        imu_msg.angular_velocity.y = math.radians(gyro[1])
        imu_msg.angular_velocity.z = math.radians(gyro[2])

        imu_msg.linear_acceleration.x = accel[0]
        imu_msg.linear_acceleration.y = accel[1]
        imu_msg.linear_acceleration.z = accel[2]

        # print("published")
        return imu_msg

if __name__ == '__main__':
    hardware_interface = Hardware_interface()
    hardware_interface.start_running()